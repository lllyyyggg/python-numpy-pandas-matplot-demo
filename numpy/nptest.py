import numpy as np

# a = np.arange(15).reshape(3, 5)
# print(a)

# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]]
# 3行5列打印数组
# 3 * 5 维度

# print(a.shape)

# 打印数组的形状
# (3, 5)

# print(a.ndim)

# 数组的维度
# 2

# print(a.dtype.name)
# int 64
# 打印数据类型


# print(type(a))
# <class 'numpy.ndarray'>

# b = np.array([1, 2, 3])
# print(b)
# [1 2 3]

# # 如何创建数组

# a = np.array([2, 3, 4])

# print(a)
# [2, 3, 4]
# print(a.dtype)
# int64

# b = np.array([1.2, 3.5, 5.1])
# print(b)
# [1.2, 3.5, 5.1]
# print(b.dtype)
# float64

# b = np.array([(1, 2, 3, 4), (5, 6, 7, 8)])
# print(b)
# [[1 2 3 4]
#  [5 6 7 8]]

# b = np.array([(1, 2, 3), (4, 5, 6)], dtype=complex)
# print(b)

# b = np.zeros((3, 4))
# print(b)

# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

# b = np.ones((2, 3, 4), dtype=np.int16)
# print(b)

# [[[1 1 1 1]
#   [1 1 1 1]
#   [1 1 1 1]]
#
#  [[1 1 1 1]
#   [1 1 1 1]
#   [1 1 1 1]]]

# b = np.empty((2, 3))
# 这个的输出结果可能不同
# print(b)
# [[ 1.28822975e-231 -2.68678112e+154  1.48219694e-323]
#  [ 0.00000000e+000  0.00000000e+000  4.17201348e-309]]

# b = np.arange(5, 50, 5)
# print(b)
# [ 5 10 15 20 25 30 35 40 45]

# b = np.arange(0, 2, 0.3)
# print(b)
# [0.  0.3 0.6 0.9 1.2 1.5 1.8]

# b = np.linspace(0, 2, 9)
# print(b)
# 切分
# [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]

# from numpy import pi

# b = np.linspace(0, 2 * pi, 100)
# print(b)
# [0.         0.06346652 0.12693304 0.19039955 0.25386607 0.31733259
#  0.38079911 0.44426563 0.50773215 0.57119866 0.63466518 0.6981317
#  0.76159822 0.82506474 0.88853126 0.95199777 1.01546429 1.07893081
#  1.14239733 1.20586385 1.26933037 1.33279688 1.3962634  1.45972992
#  1.52319644 1.58666296 1.65012947 1.71359599 1.77706251 1.84052903
#  1.90399555 1.96746207 2.03092858 2.0943951  2.15786162 2.22132814
#  2.28479466 2.34826118 2.41172769 2.47519421 2.53866073 2.60212725
#  2.66559377 2.72906028 2.7925268  2.85599332 2.91945984 2.98292636
#  3.04639288 3.10985939 3.17332591 3.23679243 3.30025895 3.36372547
#  3.42719199 3.4906585  3.55412502 3.61759154 3.68105806 3.74452458
#  3.8079911  3.87145761 3.93492413 3.99839065 4.06185717 4.12532369
#  4.1887902  4.25225672 4.31572324 4.37918976 4.44265628 4.5061228
#  4.56958931 4.63305583 4.69652235 4.75998887 4.82345539 4.88692191
#  4.95038842 5.01385494 5.07732146 5.14078798 5.2042545  5.26772102
#  5.33118753 5.39465405 5.45812057 5.52158709 5.58505361 5.64852012
#  5.71198664 5.77545316 5.83891968 5.9023862  5.96585272 6.02931923
#  6.09278575 6.15625227 6.21971879 6.28318531]

# b = np.sin(pi/4)
# print(b)

# b = np.arange(6)
# print(b)
# [0 1 2 3 4 5]

# b = np.arange(12).reshape(4, 3)

# print(b)
# 4 * 3 的矩阵
# [[ 0  1  2]
#  [ 3  4  5]
#  [ 6  7  8]
#  [ 9 10 11]]

# b = np.arange(24).reshape(2, 3, 4)
# print(b)
# 2 个 3 * 4维的数组
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]]

# print(np.arange(10000))
# [   0    1    2 ... 9997 9998 9999]
# 如果想打印完整的数组，可以修改阈值
# np.set_printoptions(threshold=np.nan)

# 基本操作
# 矩阵相减

# a = np.array([20, 30, 40])
# b = np.ones((1, 3))

# print(a-b)
# [[19. 29. 39.]]

# 矩阵平方
# print(a ** 2)
# [ 400  900 1600]

# print(10 * np.sin(a))
# 元素的sin
# [ 9.12945251 -9.88031624  7.4511316 ]

# a = np.array([
#     [1, 1],
#     [0, 1]
# ])

# print(a)
# [[1 1]
#  [0 1]]

# b = np.array([
#     [2, 0],
#     [3, 4]
# ])
# 这个表示矩阵之间元素相乘
# print(a * b)

# print(a.dot(b))
# print(a@b)
# 矩阵相乘
# [[5 4]
#  [3 4]]
# [[5 4]
#  [3 4]]

# b += 1
# print(b)
# 元素的操作
# [[3 1]
#  [4 5]]


# a = np.ones(3, dtype=np.int32)
# b = np.linspace(0, pi, 3)
#
# c = a + b
# print(c)
# 向上转型
# [1.         2.57079633 4.14159265]
# int -> float -> complex

# a = np.random.random((2, 3))
# print(a)

# print(a.sum())
# 求和
# 3.340053543749344

# print(a.min())
# 最小值
# 0.1400354882614434

# print(a.max())
# 最大值
# 0.6852195003967595

# b = np.arange(12).reshape(3, 4)
# print(b)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# print(b.sum(axis=0))
# [12 15 18 21]
# 每一列的和
# print(b.sum(axis=1))
# 每一行的和
# [ 6 22 38]

# print(b.cumsum(axis=1))
# 每一行的累计和
# [[ 0  1  3  6]
#  [ 4  9 15 22]
#  [ 8 17 27 38]]

# b = np.arange(3)
# print(np.exp(b))
# [1.        , 2.71828183, 7.3890561 ]
# c = np.array([2, -1, 4])
# print(np.add(b, c))
# 数组元素的和
# [2 0 6]

# Indexing, Slicing and Iterating

# a = np.arange(10) ** 3
# print(a)
# [  0   1   8  27  64 125 216 343 512 729]
# print(a[2])
# 8
# a[:6:2] = -1000
# print(a)
# 0-6之间每2个元素设为-1000
# a = a[::-1]


# print(a)
# 反转数组
# [729 512 343 216 125  64  27   8   1   0]

# 多维数组每一轴会有一个索引。
# def f(x, y):
#     return 10 + x + y ;


# b = np.fromfunction(f, (5, 4), dtype=int)
# print(b)
# [[10 11 12 13]
#  [11 12 13 14]
#  [12 13 14 15]
#  [13 14 15 16]
#  [14 15 16 17]]

# print(b[2, 3])
# 2行3列
# 15
# print(b[0:5, 1])
# 0-5 行 第2列
# [11 12 13 14 15]
# print(b[:, 1])
# 和上面一样
# print(b[1:3, :])
# 1到2行，所有列
# [[11 12 13 14]
#  [12 13 14 15]]
# print(b[-1])
# [14 15 16 17]
# 最后一行

# c = np.array([
#     [
#         [0, 1, 2],
#         [10, 12, 13]
#     ],
#     [
#         [100, 101, 102],
#         [110, 112, 113]
#     ]
# ])

# print(c)
# [[[  0   1   2]
#   [ 10  12  13]]
#
#  [[100 101 102]
#   [110 112 113]]]

# print(c.shape)
# (2, 2, 3)

# print(c[1, ...])
# 最外层一维
# [[100 101 102]
#  [110 112 113]]

# print(c[..., 2])
# 最里层的最后一列
# [[  2  13]
#  [102 113]]

# for row in c:
#     print(row)
#
# 打印每一行
# [[ 0  1  2]
#  [10 12 13]]
# [[100 101 102]
#  [110 112 113]]

# for e in b.flat:
#     print(e)

# 平着打印
# 10
# 11
# 12
# 13
# 11
# 12
# 13
# 14
# 12
# 13
# 14
# 15
# 13
# 14
# 15
# 16
# 14
# 15
# 16
# 17

# 形状操作

# b = np.floor(10 * np.random.random((3, 4)))
# print(b)
# [[2. 8. 0. 0.]
#  [1. 7. 5. 7.]
#  [0. 9. 7. 0.]]

# print(b.shape)
# (3, 4)

# print(b.ravel())
# 打印数组的元素打成1维的
# [5. 6. 5. 2. 4. 9. 7. 8. 6. 8. 9. 8.]

# print(b.reshape(3, 4))
# 重新改变维度
# [[8. 0. 9. 6.]
#  [1. 6. 6. 8.]
#  [7. 6. 0. 3.]]

# print(b.T)
# 数组的转制
# [[8. 0. 1.]
#  [8. 4. 7.]
#  [9. 9. 3.]
#  [4. 2. 4.]]

a = np.array([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
])

# a.resize((2, 6))
# print(a)
# 直接改变a的大小

# a = [[1, 2, 3], [4, 5, 6]]
# b = [[7, 8, 9], [10, 11, 12]]
# print(np.vstack((a,b)))
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]
#  [10 11 12]]

# print(np.hstack((a, b)))
# [[ 1  2  3  7  8  9]
#  [ 4  5  6 10 11 12]]

from numpy import newaxis

# print(np.column_stack((a, b)))
# [[ 1  2  3  7  8  9]
#  [ 4  5  6 10 11 12]]
# a = np.array([4, 2])
# b = np.array([3, 8])

# print(np.column_stack((a, b)))
# [[4 3]
#  [2 8]]

a = np.array([[1, 2, 3, 7, 8, 9],
              [4, 5, 6, 10, 11, 12]])

# print(np.hsplit(a, 3))

# 水平切分，将大数组编程小数组
# [array([[1, 2],
#        [4, 5]]), array([[ 3,  7],
#        [ 6, 10]]), array([[ 8,  9],
#        [11, 12]])]

# 2-3列作为中心点进行切分
# print(np.hsplit(a, (2, 3)))
# [array([[1, 2],
#        [4, 5]]),
#  array([[3],
#        [6]]),
#  array([[ 7,  8,  9],
#        [10, 11, 12]])
# ]


# 拷贝和视图

# a = np.arange(12)
# c = a.view()
# print(c)
# 浅复制，不能改变原来数组的结构，但是能够改变原来数组的数据

# 深拷贝

# a = np.arange(12)
# c = a.copy()
# c[:] = 10
# print(a)
# print(c)


# a = np.arange(12) ** 2
# j = np.array([[1, 2], [3, 4]])
# print(a)
# 以j的形状显示元素
# print(a[j])

# 线性代数

# a = np.array([[1, 2], [3, 4]])
# print(a.transpose())
# 转制
# [[1 3]
#  [2 4]]

